#!/usr/bin/env ruby

begin
  require "johnson"
rescue LoadError
  require "rubygems"
  require "johnson"
end

require "readline"

CONTEXT = cx = Johnson::Context.new
CONTEXT[:alert] = lambda { |m| puts m }

EXIT_VERBS = [nil] + %w(exit quit)

local_binding = binding
ruby_readline = []

def copy_history
  new_history = []
  until Readline::HISTORY.empty?
    new_history.push(Readline::HISTORY.pop)
  end
  new_history
end

def paste_history(old_history)
  until old_history.empty?
    Readline::HISTORY << old_history.pop
  end
end

def rescued(&block)
  yield
rescue Object => e
  puts e.message
  puts e.backtrace
end

def eval_in_js(expression)
  rescued { puts "=> " + CONTEXT.evaluate(expression, "(console)").inspect }
end

def eval_in_ruby(expression, bind_to)
  rescued { puts "=> " + eval(expression, bind_to).inspect }
end

options = Johnson::CLI::Options.parse!(ARGV)
options.load_paths.each { |d| $LOAD_PATH << d }
options.files_to_preload.each { |f| CONTEXT.load(f) }

unless options.files_to_evaluate.empty?
  options.files_to_evaluate.each { |f| CONTEXT.load(f) }
  exit
end

unless options.expressions.empty?
  options.expressions.each { |e| CONTEXT.evaluate(e, '-e') }
  exit
end

loop do
  input = Readline.readline("js> ", true)
  break if EXIT_VERBS.include?(input)
  
  if input =~ /^rb\s+(.+)$/
    eval_in_ruby($1, local_binding)
    next
  end
  
  if input == "rb"
    js_readline = copy_history
    paste_history(ruby_readline)
    
    loop do
      input = Readline.readline("rb> ", true)
      break if input == "js"
      exit if EXIT_VERBS.include?(input)

      if input =~ /^js\s+(.+)$/
        eval_in_js($1)
        next
      end

      eval_in_ruby(input, local_binding)
    end
    
    ruby_readline = copy_history
    paste_history(js_readline)
    next
  end
  
  eval_in_js(input)
end
